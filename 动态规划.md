# 动态规划

[toc]
## 62. 不同路径

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

示例 1：

![img](https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png)

> 输入：m = 3, n = 7
> 输出：28

示例 3：

> 输入：m = 7, n = 3
> 输出：28

示例 4：

> 输入：m = 3, n = 3
> 输出：6

```java
class Solution {
    // 递归完成
    private Map<Integer, Integer> cache = new HashMap<>();
    public int uniquePaths(int m, int n) {
        return uniquePaths(1, 1, m, n);
    }
    public int uniquePaths(int m, int n, int row, int ver) {
        int key = n * 100 + m;
        if (cache.containsKey(key)) return cache.get(key);
        if (m == row) return 1;
        if (n == ver) return 1;
        int res = uniquePaths(m + 1, n, row, ver) + uniquePaths(m, n + 1, row, ver);
        cache.put(key, res);
        return res;
    }
    // 遍历写法：速度更快
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        Arrays.fill(dp[0], 1);
        for (int i = 0; i < m; i++) {
            dp[i][0] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
}
```


## 63. 不同路径 II

一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 1 和 0 来表示。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

![img](https://assets.leetcode.com/uploads/2020/11/04/robot1.jpg)

示例 1：

> 输入：obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
> 输出：2

```java
public class Solution63 {
    // 迭代完成  速度更快
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int m = obstacleGrid.length;
        int n = obstacleGrid[0].length;
        int[][] dp = new int[m][n];
        // 初始化第一行
        for (int i = 0; i < m; i++) {  // 注意第一行和第一列的初始化问题
            if (obstacleGrid[i][0] == 1)break;
            dp[i][0] = 1;
        }
        for (int i = 0; i < n; i++) {
            if (obstacleGrid[0][i] == 1) break;
            dp[0][i] = 1;
        }
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obstacleGrid[i][j] == 1) continue;
                if (obstacleGrid[i - 1][j] != 1) {
                    dp[i][j] += dp[i - 1][j];
                }
                if (obstacleGrid[i][j - 1] != 1) {
                    dp[i][j] += dp[i][j - 1];
                }
            }
        }
        return dp[m - 1][n - 1];
    }
}
```



## 72. 编辑距离

给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。

你可以对一个单词进行如下三种操作：

插入一个字符、删除一个字符、替换一个字符


示例 1：

> 输入：word1 = "horse", word2 = "ros"
> 输出：3
> 解释：
> horse -> rorse (将 'h' 替换为 'r')
> rorse -> rose (删除 'r')
> rose -> ros (删除 'e')

示例 2：

> 输入：word1 = "intention", word2 = "execution"
> 输出：5
> 解释：
> intention -> inention (删除 't')
> inention -> enention (将 'i' 替换为 'e')
> enention -> exention (将 'n' 替换为 'x')
> exention -> exection (将 'n' 替换为 'c')
> exection -> execution (插入 'u')

```java
public class Solution72 {
    public int minDistance(String word1, String word2) {
        int l1 = word1.length();
        int l2 = word2.length();
        int[][] dp = new int[l1 + 1][l2 + 1];

        for (int i = 1; i < l1 + 1; i++) {
            dp[i][0] = i;
        }
        for (int i = 1; i < l2 + 1; i++) {
            dp[0][i] = i;
        }
        for (int i = 1; i <= l1; i++) {
            for (int j = 1; j <= l2; j++) {
                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1;
                }
            }
        }
        return dp[l1][l2];
    }

    private int min(int i, int i1, int i2) {
        return Math.min(i, Math.min(i1, i2));
    }
}
```

## 300. 最长递增数列

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。


示例 1：

> 输入：nums = [10,9,2,5,3,7,101,18]
> 输出：4
> 解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。

示例 2：

> 输入：nums = [0,1,0,3,2,3]
> 输出：4

示例 3：

> 输入：nums = [7,7,7,7,7,7,7]
> 输出：1

```java
import java.util.Arrays;

public class Solution300 {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 1)
            return 1;
        int[] dp = new int[nums.length];
        Arrays.fill(dp, 1);
        int res = 0;
        for (int i = 1; i < nums.length; i++) {
            for (int j = 0; j < i; j++) {  // 更新DP
                if (nums[j] < nums[i])
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

## 322-零钱兑换

不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

示例 1：

> 输入：coins = [1, 2, 5], amount = 11
> 输出：3 
> 解释：11 = 5 + 5 + 1

示例 2：

> 输入：coins = [2], amount = 3
> 输出：-1

示例 3：

> 输入：coins = [1], amount = 0
> 输出：0

```java
public class Solution322 {
    /**
     * 确定状态方程 min(1 + dp(amount - icon))
     */
    private Map<Integer, Integer> cache = new HashMap<>();  // 引入备忘录
    public int coinChange(int[] coins, int amount) {
        if (cache.containsKey(amount)) return cache.get(amount);
        if (amount < 0) return -1;
        if (amount == 0) return 0;
        int res = Integer.MAX_VALUE;
        for (int coin : coins) {
            int sub = coinChange(coins, amount - coin);
            if (sub == -1) continue;
            res = Math.min(res, 1 + sub);
        } 
        cache.put(amount, res != Integer.MAX_VALUE ? res : -1);
        return res != Integer.MAX_VALUE ? res : -1;
    }

    public int coinChange2(int[] coins, int amount) {   // 遍历写法
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, amount + 1);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}
```

## 509. 斐波那契数列

```java
public class Solution509 {
    private Map<Integer, Integer> cache = new HashMap<>();

    public int fib(int n) {   // 传统实现
        if (n == 0) return 0;
        if (n == 1) return 1;
        return fib(n - 1) + fib(n - 2);
    }

    public int fib2(int n) {  // 引入备忘录
        if (cache.containsKey(n)) return cache.get(n);
        if (n == 0) return 0;
        if (n == 1) return 1;
        int sum = fib(n - 1) + fib(n - 2);
        cache.put(n, sum);
        return sum;
    }

    public int fib3(int n) {  // 迭代实现
        if (n == 0) return 0;
        if (n == 1) return 1;
        int pre = 0;
        int cur = 1;
        int sum = 0;
        for (int i = 2; i <= n; i++) {
            sum = pre + cur;
            pre = cur;
            cur = sum;
        }
        return sum;
    }
}

```